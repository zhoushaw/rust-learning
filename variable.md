## 变量与可变性

* 声明变量使用 let 关键字，它的类型可以不标注
* 默认情况下，变量是不可变的 （immutable）
    * 通过 mut 关键词让其可变
* 变量和常量
    * 绑定之后值是不可变的
    * 声明常量使用 const 关键字，它的类型必须被标注
    * 常量可以在任何作用域内进行声明，包括全局作用域
    * 常量只能绑定在常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值 
    * 在程序运行期间，常量在其声明的作用域内一直有效
    * Rust 里常量使用全大写字母，每个单词之间用下划线分开

## Shadowing（隐藏）

* 可以使用相同的名字声明新的变量，新的变量就会 shadow（隐藏）之前声明的同名变量
* shadow 和把变量标记为 mut 是不一样的
    * 如果不使用 let 关键字，那么重新给非 mut 的变量赋值会导致编译时错误
    * 而使用 let 声明的同名新变量，也是直接改值的
    * 使用 let 声明的同名新变量，它的类型可以与之前不同


## 数据类型

Rust 是静态编译语言，在编译时，必须知道所有变量的类型

* 基于使用的值，编译器通常能够推断出它的具体类型
* 但如果可能的类型比较多（例如把 String 转成整数的 parse 方法），就必须添加类型的标注，否则编译会报错

### 标量类型

一个标量类型代表一个单个的值
Rust 有四个主要的标量类型：
* 整数类型
* 浮点类型
* 布尔类型

#### 整数类型

* 没有小数部分
* 例如 u32 就是一个无符号的整数类型，占据 32 位的空间
* 无符号整数类型以 u（unsigned） 开头（没有正负号，非负的）
    * 无符号的范围： 0 到 2^n-1，包括两头
* 有符号的整数类型以 i（signed） 开头（有正负号）
    * 有符号的范围： -（2^n-1）到 2^(n-1)-1，包括两头
* Rust 整数类型列表
    * 8-bit i8 u8
    * 16-bit i16 u16
    * 32-bit i32 u32
    * 64-bit i64 u64
    * 12-bit i128 u128
    * arch isize usize
* isize 和 usize 类型
    * isize 和 usize 类型的位数由程序运行的计算机的架构所决定
    * 如果是 64 为计算机，那就是 64 位的
    * 使用 isize 和 usize 的主要场景是对某种集合进行索引操作
* 整数的字面值
    * Decimal 98_222 十进制
    * Hex 0xff 16进制
    * Octal 0o77 八进制
    * Binary 0b111_0000 二进制
    * Byte(u8 only) b'A' 字节
* 整数的默认类型是 i32
* 整数溢出
    * 例如：u8 的范围是 0~255，如果你把一个 u8 变量的值设置为 256，那么
        * 调试模式下：Rust 会检查整数溢出，如果移除发生，程序在运行时就会 panic
        * 发布模式下（--release）编译：Rust 不会检查可能导致 panic 的整数溢出
            * 如果移除发生：Rust 会执行 “环绕” 操作
            * 256 会变成 0，257 变成 1
            * 但程序不会 panic

#### 浮点类型

Rust 有两种基础的浮点类型，也就是含小数部分的类型

* f32，32 位，单精度
* f64，65 位，双精度

Rust 的浮点类型使用了 IEEE-754 标准来表述
f64 是默认类型，因为在现代 CPU 上 f64 和 f32 的速度差不多，而且精读更高


#### 布尔类型

Rust 的布尔类型也有两个值： true 和 false

* 一个字节大小
* 符号是 bool

### 字符类型

* Rust 语言中 char 类型被用来描述语言中最基础的单个字符
* 字符类型的字面值使用单引号
* 占用 4 字节大小
* 是 Unicode 标量值，可以表示比 ASCII 多得多的字符内容：拼音、中日韩文、零长度空白字符、emoji 表情等
* 但 Unicode 中并没有 “字符” 概念，所以直觉上认为字符也许与 Rust 中的概念并不相符


### 复合类型

* 复合类型可以将多个值放在一个类型里面
* Rust 提供了两种基础的复合类型：元组（Tuple）、数组


#### Tuple

* Tuple 可以将多个类型的多个值放在一个类型里
* Tuple 的长度是固定的：一旦声明就无法改变



> 创建 Tuple

* 在小括号里，将值用逗号分开
* Tuple 中的每一个值都对应一个类型，Tuple 中个元素的类型不必相同

> 获取 Tuple 的元素值

* 可以使用模式匹配来解构（destructure）一个 Tuple 来获取元素的值
* 在 tuple 变量使用点标记法，后面接元素的索引



#### 数组

如果想让数据存在栈内存 stack（栈） 里面，而不是 heap（堆）上，或者想保证有固定数量的元素，这时使用数组更有好处


* 数组也可以将多个值放在一个类型里
* 数组中每个元素的类型必须相同
* 数组的长度也是固定的
* Vector 更灵活与数组类似，它由标准库提供。Vector 的长度可以改变

> 声明一个数组

* 在中括号里面，各个值通过逗号分开

> 数组的类型

* 数组的类型以这种形式标识： [类型;长度]
* let a: [i32;5] = [1,2,3,4,5];

> 另一种数组的申明方式

* 在中括号指定初始值
* 然后是一个 “;”
* 最后是一个数组的长度
* `let a = [3;5];` === `let a [3,3,3,3,3];`

> 如何访问数组的元素

* 数组是 stack 上分配的单块内存
* 可以通过索引来访问数组的元素
* 如果访问的索引超出了数组的范围
    * 编译会通过
    * 运行时会报错（runtime 时会 panic）
    * Rust 不会允许棋继续访问相应地址的内存 

 
