# 所有权

所有权是 Rust 最独特的特性，它让 Rust 无需 GC 就可以保证内存安全

## 什么是所有权

* Rust 的核心特性就是所有权
* 所有程序在运行时都必须管理他们使用计算机内存的方式
    * 有些语言有垃圾收集机制，在程序运行时，它们会不断地寻找不在使用的内存
    * 在其他语言中，程序员必须显示地分配和释放内存
* Rust 采用了第三种方式
    * 内存是通过一个所有权系统来管理的，其中包含一组编译器在编译是检查的规则
    * 当程序运行时，所有权特性不会减慢程序的运行速度


## Stack vs Heap（栈内存和堆内存）

* 在像 Rust 这样的系统级编程语言里，一个值在 Stack 上还是 heap 上对语言的行为和为什么要做某些决定是有重大影响的
* 在代码运行的时候，Stack 和 Heap 都是可用的内存，但他们的结构很不相同

## 存储数据

* Stack 按值的接收顺序来存储，按相反的顺序将它们移除（后进先出，LIFO）
    * 添加数据叫做压入栈
    * 移除数据叫做弹出栈
    * 添加数据到 Stack 比添加到 Heap 上要快的多，因为操作系统不需要寻找用来存储数据的空间，那个位置永远都在 Stack 的顶端
* 所有存储在 Stack 上的数据必须拥有已知的固定的大小
    * 编译时大小未知的数据或运行时大小可能发生变化的数据必须存储在 heap 上
    * 因为指针大小是固定的，所以可以把指针存放在 stack 上
    * 如果想要实际数据，你必须使用指针来定位
* Heap 内存组织性差一些：
    * 当把数据放入 heap 时，会请求一定数量的空间
    * 操作系统在 heap 里找到一块足够大的空间，把它标记为在用，并返回一个指针，也就是这个空间地址
    * 这个过程叫做 heap 上进行分配，有时仅仅称为“分配”
    * Heap 分配内存需要更多的工作
        * 找一个足够大的空间存放数据
        * 做好记录方便下次分配



## 访问数据

* Heap
    * 访问 Heap 的数据中要把 Stack 中的数据慢，因为通过指针才能找到 heap 中的数据
* Stack
    * 如果数据存放的距离比较近，那么处理器的处理速度就会更快一些（Stack 上）
    * 如果数据存放的距离比较远，那么处理速度就会慢一些（heap 上）


## 函数调用

当代码调用函数时，值被传入到函数（包括指向 heap 的指针）。函数本地的变量被压倒 stack 上。当函数结束后，这些值会从 stack 上弹出


## 所有权存在的原因

* 所有权解决的问题
    * 跟踪代码哪些部分正在使用 heap 的哪些数据
    * 最小化 heap 上的重复数据量
    * 清理 heap 上未使用的数据以避免空间不足
* 一旦懂得所有权，就不需要经常去想 stack 或 heap 了
* 管理 heap 数据是所有权存在的原因

## 所有权规则

* 每个值都有一个变量，这个变量是该值的所有者
* 每个值同时只能有一个所有者
* 当所有者超出作用域时，该值将被删除



## 变量的作用域

* Scope 就是程序的一个有效范围


## String 类型

String 比那些基础标量数据类型更复杂，存储在堆上面

字符串字面值：程序里手写的哪些字符串值，它们是不可变的

> 创建 String 类型的值

* 可以使用 from 函数从字符串字面值创建 String 类型：`let s = String::from("hello");`
    * `::` 标识 from 是 String 类型下的函数
* 这类字符串是可以被修改的


```rust
fn main() {
    let mut s = String::from("Hello");
    s.push_str(", World");
    println!("{}",s);
}
```

* String 类型的值可以修改，但是字面量的不可修改
    * 内存和分配的方式存在差异
        * 字符串字面值，在编译时就知道他的内容了，其文本内容直接被硬编码到最终的可执行文件内。速度快且高效，因为其不可变性
    * String 类型，为了支持可变性，需要在 heap 上分配内存来保存编译时位置的文件内容
        * 操作系统必须在运行时来请求内存，通过调用 String::from 来实现的
        * 当使用完 String 之后，需要使用某种方式将内存返回操作系统
            * 在拥有 GC 的语言中，GC 会跟踪并清理不在使用的内存
            * 没有 GC，就需要识别内存何时不在使用，并调用代码将它回收
                * 如果忘了就会浪费内存
                * 如果提前回收则会发生异常

## 内存分配

Rust 采用了 GC 和手动回收内存不同的方式，对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动的交给操作系统

* 当变量走出作用域时，Rust 会对用 drop 函数

> 变量和数据交互的方式：移动（Move）

* 多个变量可以与同一个数据使用一种独特的方式交互


* 整数是已知且固定大小的简单值

```rust

let x = 5;
let y = x;


let s1 = String::from("hello");
let s2 = s1;
```

* String 由 3 部分组成
    * 一个指向存放字符串内容的内存指针
    * 一个长度
    * 一个容量
    * 上述三个信息存放在栈中
* 存放字符串内容的部分在 heap 中
* 长度 len，就是存放字符串所需的字节数
* 容量 capacity 是指 String 从操作系统总共获得内存的总字节数
* 当对 String 类型的数据进行复制时
    * 复制的是 String 组成的三部分
    * 指针的地址还是相同的
    * 指针指向 heap 上的数据不变
* 当变量离开作用域是，Rust 会自动调用 drop 函数并将变量使用的 heap 内存释放
* Rust 使用移动来复制

> clone

* 如果想对 heap 上面的 String 数据进行深度拷贝，而不仅仅是 Stack 上的数据，可以使用 clone 方法
* clone 比较消耗内存，会让 stack 和 heap 上的数据都复制一遍

> copy

* 可是用于像整数这样完全存放在 stack 上面的类型
* 如果一个类型实现了 Copy 这个 trait，那么旧的变量在复制后仍然可用
* 如果一个类型或该类型的一部分实现了 Drop trait，那么 Rust 不允许让它再去实现 Copy trait 了


> Copy trait

* 任何简单标量的组合类型都可以实现 Copy
* 任何需要分配内存或某种资源的都不是 Copy 
* Copy trait 的类型
    * 所有整数类型：u32 ...
    * bool
    * char
    * 所有浮点类型：f64 ...
    * Tuple（元组），如果其所有的字段都是 Copy 的
    * (i32，i32) 是
    * (i32,String) 不是


## 所有权和函数

将变量作为参数传入函数时，变量是放在「堆」上会进行转移，放在「堆栈」上会进行拷贝，因此将放在对上的「变量」传入函数时，需要显示返回否则将会出现异常

```rust
fn main() {
    let s1 = String::from("hello");   
    let s3 = takes_and_gives_back(s1); // 返回值可进行使用
    println!("'{}'", s3); // 使用返回的值正常，所有权回归
    println!("'{}'", s1); // 不正常所有权已经释放无法在使用
} 

fn takes_and_gives_back(s: String) -> String {
    s
}
```

但是每次函数使用放在堆上的变量时都需要返回则会需要写大量不必要乏味的代码，因此可以通过「索引」来解决所有权转义的问题。

> 使用索引来解决所有权的问题

```rust
fn main() {
    let s1 = String::from("hello");   
    takes_and_gives_back(&s1); // 返回值可进行使用
    println!("'{}'", s1); // 正常使用所有权并未发生转义
} 

fn takes_and_gives_back(s: &String) -> String {
    s
}
```

* 默认情况下索引借用的内容无法修改，需要声明 mut 
* 同一时间的变量只能有一个 mut 的变量
* 索引借用不能同时存在两个及两个以上
* 不能同时存在可变索引和不可变索引（同时存在的范围在最后一次使用的地方，若最后一次时候之后存在可变与不可变不会影响）
* 切片采用索引的方式获取变量的部分内容，较容易出现不可变和可变的情况出现

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```


## 总结

Rust 通过所有权、借用、切片在编译时来保证内存安全，当数据超出使用范围时会自动回收